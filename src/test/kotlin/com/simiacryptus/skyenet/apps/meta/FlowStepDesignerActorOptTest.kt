package com.simiacryptus.skyenet.apps.meta

import com.simiacryptus.openai.OpenAIClient
import com.simiacryptus.skyenet.actors.CodingActor
import com.simiacryptus.skyenet.actors.SimpleActor
import com.simiacryptus.skyenet.actors.opt.ActorOptimization
import com.simiacryptus.skyenet.actors.opt.Expectation
import com.simiacryptus.skyenet.heart.KotlinInterpreter
import org.slf4j.LoggerFactory
import org.slf4j.event.Level

object FlowStepDesignerActorOptTest {

    private val log = LoggerFactory.getLogger(FlowStepDesignerActorOptTest::class.java)

    @JvmStatic
    fun main(args: Array<String>) {
        try {
            ActorOptimization(
                OpenAIClient(
                    logLevel = Level.DEBUG
                )
            ).runGeneticGenerations(
                populationSize = 7,
                generations = 5,
                actorFactory = { CodingActor(
                    interpreterClass = KotlinInterpreter::class,
                    details = it,
                ) },
                resultMapper = { it.getCode() },
                prompts = listOf(
                    """
                    |You are a software implementation assistant.
                    |Your task is to implement a step in the logic flow of a ChatGPT-based actor system.
                    |Respond to the user request with an implementation of the requested logic flow step.
                    |Preceding "assistant" messages define the existing code of the system, which you will append to.
                    """.trimMargin().trim(),
                ),
                testCases = listOf(
                    ActorOptimization.TestCase(
                        userMessages = listOf(
                            "Design a software project designer",
                            "# Software Project Designer System Design Document\n\n## Introduction\n\nThe Software Project Designer is a system designed to assist users in creating a structured plan for software development projects. It leverages GPT actors to interactively guide the user through the process of defining project requirements, architecture, tasks, and milestones. The system is composed of various specialized actors that collaborate to generate a comprehensive project design document.\n\n## System Overview\n\nThe system is structured around a community of GPT actors, each with a specific role in the project design process. These actors are:\n\n1. **Requirements Actor**: Captures and organizes user requirements.\n2. **Architecture Actor**: Suggests software architecture based on requirements.\n3. **Task Breakdown Actor**: Breaks down architecture into actionable tasks.\n4. **Milestone Planner Actor**: Organizes tasks into milestones and timelines.\n5. **Documentation Actor**: Compiles all information into a project design document.\n\n## Actors Description\n\n### 1. Requirements Actor (Parsed Actor)\n\n- **Purpose**: To interact with the user to gather and categorize software project requirements.\n- **Usage**: The actor prompts the user for requirements, which are then parsed into a structured format suitable for further processing by other actors.\n\n### 2. Architecture Actor (Script Actor)\n\n- **Purpose**: To propose a software architecture that aligns with the captured requirements.\n- **Usage**: Based on the input from the Requirements Actor, this actor uses predefined symbols and functions to generate an architectural blueprint script, which can be executed to visualize the proposed architecture.\n\n### 3. Task Breakdown Actor (Parsed Actor)\n\n- **Purpose**: To decompose the proposed architecture into a set of actionable development tasks.\n- **Usage**: This actor parses the architecture script into a list of tasks, categorizing them by development phase, technology stack, and estimated effort.\n\n### 4. Milestone Planner Actor (Script Actor)\n\n- **Purpose**: To organize tasks into milestones and create a project timeline.\n- **Usage**: The actor takes the task list and applies project management principles to sequence tasks, define milestones, and estimate timelines using a script that can be executed to produce a Gantt chart or similar visual timeline.\n\n### 5. Documentation Actor (Simple Actor)\n\n- **Purpose**: To compile all the information generated by the previous actors into a cohesive and comprehensive project design document.\n- **Usage**: The actor processes the outputs from all other actors and formats them into a document, complete with an introduction, table of contents, sections for requirements, architecture, task breakdown, milestones, and appendices if needed.\n\n## Logical Flow of the System\n\n1. **User Interaction**: The user initiates the process by interacting with the Requirements Actor to input project requirements.\n2. **Requirements Parsing**: The Requirements Actor processes the user input and parses it into a structured format.\n3. **Architecture Generation**: The parsed requirements are passed to the Architecture Actor, which generates a software architecture proposal script.\n4. **Task Breakdown**: The Architecture Actor's output is fed into the Task Breakdown Actor, which creates a detailed list of development tasks.\n5. **Milestone Planning**: The list of tasks is provided to the Milestone Planner Actor, which organizes them into milestones and timelines.\n6. **Documentation Compilation**: All the generated data from the previous steps is compiled by the Documentation Actor into a final project design document.\n7. **Review and Iteration**: The user reviews the document and may interact with any of the actors again to refine the project design.\n8. **Finalization**: Once the user is satisfied, the final project design document is generated and can be exported or shared.\n\n## Conclusion\n\nThe Software Project Designer system is an innovative approach to streamline the project planning process. By leveraging specialized GPT actors, the system facilitates an interactive and iterative design experience, resulting in a well-structured and detailed project plan. This document serves as a blueprint for the development of the Software Project Designer system.",

                            // This should use the assistant voice
                            "\nimport com.simiacryptus.openai.OpenAIClient\nimport com.simiacryptus.skyenet.actors.SimpleActor\n\nclass RequirementsActor(api: OpenAIClient) : SimpleActor(\n    prompt = \"Please provide the requirements for your software project:\",\n    api = api\n) {\n    override fun processResponse(response: String): String {\n        // Parse the user's response and categorize the requirements\n        val parsedRequirements = parseRequirements(response)\n\n        // Convert the parsed requirements into a formatted string\n        val formattedRequirements = formatRequirements(parsedRequirements)\n\n        // Return the formatted requirements as the actor's response\n        return formattedRequirements\n    }\n\n    private fun parseRequirements(response: String): List<String> {\n        // Implement your logic to parse the user's response and extract the requirements\n        // You can use regular expressions or any other parsing technique\n\n        // For example, you can split the response by newlines to get individual requirements\n        return response.split(\"\\n\")\n    }\n\n    private fun formatRequirements(requirements: List<String>): String {\n        // Implement your logic to format the parsed requirements into a readable format\n        // You can use string concatenation or any other formatting technique\n\n        // For example, you can join the requirements with bullet points\n        return requirements.joinToString(prefix = \"- \", separator = \"\\n- \")\n    }\n}\n\nval api = OpenAIClient()\nval requirementsActor = RequirementsActor(api)\n\n\n\n",

                            // Taken from parsed task list
                            "Implement User Interaction"
                        ),
                        expectations = listOf(
                            Expectation.ContainsMatch("""search\(.*?\)""".toRegex(), critical = false),
                            Expectation.VectorMatch("Great, what kind of book are you looking for?")
                        )
                    )
                ),
            )
        } catch (e: Throwable) {
            log.error("Error", e)
        } finally {
            System.exit(0)
        }
    }

}